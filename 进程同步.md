# 进程同步

## 进程同步的基本概念

- 两种形式的制约关系

    - 间接相互制约关系
    
        同处于一个系统中的进程，通常都共享着某种系统资源，如共享CPU、共享 I/O 设备等。所谓间接相互制约即源于这种资源共享，例如，有两个进程 A和 B，如果在A进程提出打印请求时，系统已将惟一的一台打印机分配给了进程 B，则此时进程A只能阻塞；一旦进程B将打印机释放，则A进程才能由阻塞改为就绪状态。

    - 直接相互制约关系。
    
        这种制约主要源于进程间的合作。例如，有一输入进程A通过单缓冲向进程B提供数据。当该缓冲空时，计算进程因不能获得所需数据而阻塞，而当进程A把数据输入缓冲区后，便将进程B唤醒；反之，当缓冲区已满时，进程 A 因不能再向缓冲区投放数据而阻塞，当进程B将缓冲区数据取走后便可唤醒 A。

- 临界资源

- 临界区

    人们把在每个进程中访问临界资源的那段代码称为临界区(critical section)

- 同步机制应遵循的规则

    - 空闲让进。当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。

    - 忙则等待。当已有进程进入临界区时，表明临界资源正在被访问，因而其它试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。
    
    - 有限等待。对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。
    
    - 让权等待。当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态
    
## 信号量机制

- 整型信号量

    把整型信号量定义为一个用于表示资源数目的整型量S，它与一般整型量不同，除初始化外，仅能通过两个标准的原子操作(AtomicOperation)wait(S)和 signal(S)来访问

    ```
    func wait(s int) {
        for s <= 0 {
        }
        
        s = s -1
    }
    
    func signal(s int) {
        s = s + 1
    }
    ```

- 记录型信号量

    在整型信号量机制中的wait操作，只要是信号量S≤0，就会不断地测试。因此，该机制并未遵循“让权等待”的准则，而是使进程处于“忙等”的状态。记录型信号量机制则是一种不存在“忙等”现象的进程同步机制。但在采取了“让权等待”的策略后，又会出现多个进程等待访问同一临界资源的情况。为此，在信号量机制中，除了需要一个用于代表资源数目的整型变量value外，还应增加一个进程链表指针L，用于链接上述的所有等待进程。记录型信号量是由于它采用了记录型的数据结构而得名的。它所包含的上述两个数据项可描述为

    ```
    type semaphore struct {
        value int // 资源数目
        L ListOfProcess // 进程链表指针
    }
    
    // 意味着进程请求一个单位的该类资源，使系统中可供分配的该类资源数减少一个
    func wait(s *semaphore) {
        s.value = s.value - 1
        
        // 表示该类资源已分配完毕
        if s.value < 0 {
            // 因此进程应调用block原语，进行自我阻塞，放弃处理机，并插入到信号量链表S.L中
            block(s.L)
        }
    }
    
    // 表示执行进程释放一个单位资源，使系统中可供分配的该类资源数增加一个
    func signal(s *semaphore) {
        s.value = s.value + 1
        
        // 若加1后仍是S.value≤0，则表示在该信号量链表中，仍有等待该资源的进程被阻塞，故还应调用wakeup原语，将S.L链表中的第一个等待进程唤醒
        if (s.value <= 0) {
            wakeUp(s.L)
        }
    }
    ```
    
    如果 S.value 的初值为1，表示只允许一个进程访问临界资源，此时的信号量转化为互斥信号量，用于进程互斥。

- AND 型信号量

    上述的进程互斥问题，是针对各进程之间只共享一个临界资源而言的。在有些应用场合，是一个进程需要先获得两个或更多的共享资源后方能执行其任务。
    
    AND 同步机制的基本思想是：将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源也不分配给它。

- 信号量集

    在记录型信号量机制中，wait(S)或 signal(S)操作仅能对信号量施以加 1 或减 1 操作，意味着每次只能获得或释放一个单位的临界资源。而当一次需要 N 个某类临界资源时，便要进行N次wait(S)操作，显然这是低效的。此外，在有些情况下，当资源数量低于某一下限值时，便不予以分配。因而，在每次分配之前，都必须测试该资源的数量，看其是否大于其下限值。基于上述两点，可以对 AND 信号量机制加以扩充，形成一般化的“信号量集”机制
    
    Swait(S，d，d)。此时在信号量集中只有一个信号量S，但允许它每次申请 d 个资源，当现有资源数少于 d 时，不予分配
    
## 信号量的应用

* 利用信号量实现进程互斥

    为使多个进程能互斥地访问某临界资源，只须为该资源设置一互斥信号量 mutex，并设 其初始值为 1，然后将各进程访问该资源的临界区 CS 置于 wait(mutex)和 signal(mutex)操作之间即可。这样，每个欲访问该临界资源的进程在进入临界区之前，都要先对mutex执行wait操作，若该资源此刻未被访问，本次 wait 操作必然成功，进程便可进入自己的临界区，这时若再有其他进程也欲进入自己的临界区，此时由于对mutex执行wait操作定会失败，

* 利用信号量实现前趋关系

    还可利用信号量来描述程序或语句之间的前趋关系。设有两个并发执行的进程 P1 和 P2。P1中有语句S1；P2中有语句S2。我们希望在S1执行后再执行 S2。为实现这种前趋关系，我们只须使进程P1和P2共享一个公用信号量 S，并赋予其初值为0，将signal(S)操作放在语句S1后面；而在S2语句前面插入 wait(S)操作，即在进程P1中，用S1；signal(S)；在进程P2中，用wait(S)；S2；由于S被初始化为0，这样，若P2先执行必定阻塞，只有在进程P1执行完 S1；signal(S)；操作后使 S 增为 1 时，P2 进程方能执行语句S2成功。

## 管程机制

